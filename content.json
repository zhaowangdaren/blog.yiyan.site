{"meta":{"title":"yiyan.site","subtitle":null,"description":null,"author":"yiyan.site","url":"http://yiyan.site"},"pages":[{"title":"","date":"2018-07-16T06:08:16.133Z","updated":"2018-07-15T00:07:28.000Z","comments":true,"path":"manifest.json","permalink":"http://yiyan.site/manifest.json","excerpt":"","text":"{\"name\":\"App\",\"icons\":[{\"src\":\"/android-icon-36x36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\",\"density\":\"0.75\"},{\"src\":\"/android-icon-48x48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\",\"density\":\"1.0\"},{\"src\":\"/android-icon-72x72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\",\"density\":\"1.5\"},{\"src\":\"/android-icon-96x96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\",\"density\":\"2.0\"},{\"src\":\"/android-icon-144x144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\",\"density\":\"3.0\"},{\"src\":\"/android-icon-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\",\"density\":\"4.0\"}]}"},{"title":"关于","date":"2018-09-08T04:18:25.000Z","updated":"2018-09-08T04:26:53.076Z","comments":true,"path":"about/index.html","permalink":"http://yiyan.site/about/index.html","excerpt":"","text":"扫码关注仪炎开发公众号"}],"posts":[{"title":"Facebook:使用高性能的开源TLS库Fizz大规模部署TLS1.3","slug":"facebook-Fizz","date":"2018-08-22T11:15:28.000Z","updated":"2018-08-23T12:02:38.451Z","comments":true,"path":"2018/08/22/facebook-Fizz/","link":"","permalink":"http://yiyan.site/2018/08/22/facebook-Fizz/","excerpt":"","text":"原文新一代传输层安全协议TLS1.3增加了几项新功能，可以使互联网流量更加安全，包括加密握手消息以保证证书私密，重新设计密钥的派生方式，以及零往返连接设置，这使得某些请求比TLS1.2快。每天有超过10亿人使用Facebook与他们的朋友和家人联系，正是TLS1.3将他们的数据从应用程序传输到我们的服务器（然后，我们把数据提供给别人…最近用户隐私把Facebook折腾的够呛）。为了在Facebook上实现TLS1.3，我们创建了Fizz：一个用C++14编写的强大、高性能的TLS库。除了TLS1.3附带的协议增强功能外，Fizz还提供了许多功能，包括默认支持异步I/O，以及分散和收集I/O以消除对额外数据副本的需求。 我们现在已经在我们的移动应用程序Proxygen、负载均衡器、内部服务，甚至我们的QUIC库mvfst中全局部署了Fizz和TLS1.3。现在，Facebook超过50%的互联网流量使用了TLS1.3进行保护。在我们的移动应用程序上部署了TLS1.3的新特性：0个RTT发送数据。Fizz现在每秒处理数百万次TLS1.3握手。我们相信这使Fizz成为互联网上TLS1.3和0-RTT往返数据的最大部署。Fizz不仅减少了延迟，还减少了每天执行数万亿请求的服务器CPU的使用率。我们很高兴能够开源Fizz，以帮助加速在互联网上部署TLS1.3，并帮助其他人使他们的应用和服务更快、更安全。 性能我们的团队与互联网工程任务组（IETF）合作多年，致力于标准化TLS1.3。以前，为了提高TLS的安全性和性能，我们部署了Zero协议。这是一种私有协议，允许我们尝试建立0-RTT安全连接。使用0-RTT数据可减少使用TLS的请求延迟以及部署TLS所需的延迟开销。Fizz提供与Zero洗衣相同的TLS1.3的可靠性和性能，因此我们使用TLS1.3取代了我们的Zero协议部署。 性能也是Fizz关注的重点。通过零拷贝加解密，与我们基础架构的其他部分紧密集成以及其他优化，我们发现Fizz减少了内存和CPU的占用率。我们的负载均衡器综合基准测试显示，吞吐量比我们之前的堆栈高出约10%，但是我们不会骄傲，我们将会继续致力于提供Fizz性能。 通Zero协议一样，相比于TLS1.2，TLS1.3在握手阶段建立安全连接时显著减少了延迟。这样可以改善用户体验，尤其是在没有可重用连接的时候，比如应用程序启动时。 减少延迟的百分比（TLS1.3与TLS1.2在建立连接时） 默认异步在TLS的现代部署中，服务器遍布全球。TLS负载均衡器位于一个位置是常见的，而TLS证书签名密钥由位于世界各地的另一个安全服务提供。像无密钥SSL（更像是一种拆分握手过程，私钥解密在一台服务器上，其他步骤可以在其他服务器上完成）之类的技术，被运用到将加密计算分发到不同的主机。 由于服务器通常希望能够在握手过程中能够调用其他服务，因此异步IO变得非常重要。当我们在编写Fizz时，我们希望将多个功能拆解到其他远程的服务器上，例如证书操作。因此，Fizz服务默认情况下是异步的。我们利用futures来提供一个简单的异步API，来自Fizz的任何回调都可以异步相应，而不会阻止服务处理其他握手。对于其他用例，向Fizz添加新的异步回调也非常容易。 零拷贝写多个库中的TLS APIs要求用户提供连续的内存块。TLS库加密连续内存块中的数据并将其写入socket中。然后，应用程序通常以不同存储器位置中的几个数据块的形式将数据保存在存储器中，而不是存储在一个连续的存储器块中。在其他库中，应用程序需要将数据拷贝到连续的内存位置，以便将其提供给TLS库。此复制操作会增加延迟开销。Fizz拥有支持分散、聚合I/O的API，其所有API都默认接受分散、聚合的抽象作为输入。这允许用户传入分块数据，然后Fizz将数据加密到分块内存中，从而避免了复制数据的需要。因此，使用Fizz的应用程序执行的内存分配和副本更少，这是高性能应用程序的一个重要考虑因素。","categories":[],"tags":[{"name":"TLS1.3 Facebook","slug":"TLS1-3-Facebook","permalink":"http://yiyan.site/tags/TLS1-3-Facebook/"}]},{"title":"10-SQL-tricks","slug":"10-SQL-tricks","date":"2018-07-17T11:29:22.000Z","updated":"2018-07-17T11:29:36.076Z","comments":true,"path":"2018/07/17/10-SQL-tricks/","link":"","permalink":"http://yiyan.site/2018/07/17/10-SQL-tricks/","excerpt":"","text":"","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yiyan.site/tags/SQL/"}]},{"title":"H5:echarts的tooltip与datazoom的优化","slug":"H5-echarts的tooltip与datazoom的优化","date":"2018-05-25T05:06:37.000Z","updated":"2018-07-15T07:29:58.895Z","comments":true,"path":"2018/05/25/H5-echarts的tooltip与datazoom的优化/","link":"","permalink":"http://yiyan.site/2018/05/25/H5-echarts的tooltip与datazoom的优化/","excerpt":"echarts版本3.X.X 在移动端同时使用Echarts的tooltip和datazoom时，你会发现tooltip显示的时候很难去对图表进行放大、缩小、水平移动，也就是比较难触发datazoom事件，用户体验有点差。因此，本文提出了一些优化方法，以便提高用户体验。","text":"echarts版本3.X.X 在移动端同时使用Echarts的tooltip和datazoom时，你会发现tooltip显示的时候很难去对图表进行放大、缩小、水平移动，也就是比较难触发datazoom事件，用户体验有点差。因此，本文提出了一些优化方法，以便提高用户体验。 1. 交互套路既然要优化，那就需要将tooltip和datazoom这两个事件拆分开，不能让它们同时触发。所以，交互的总方针是： tooltip隐藏时，即允许datazoom也允许显示tooltip； 点击，tooltip显示，datazoom无效；再次点击，tooltip隐藏，允许datazoom 只有tooltip隐藏时，才允许datazoom。 2. 实现实现时需要接管tooltip的触发，同时也要控制datazoom是否可用 2.1 接管tooltip2.1.1 echarts配置echarts在配置tooltip提示框触发的条件：123tooltip: &#123; triggerOn: 'none'&#125; 不在’mousemove’或’click’时触发，我们改用dispatchAction来触发tooltip显示。 2.1.2 主动触发tooltip，允许datazoom我们需要处理图表dom标签的Touch事件，从而来主动分发showtip事件。按照我们的交互总方针，以下流程中的每一次允许tooltip，都伴随这禁用datazoom；每一次隐藏tooltip都伴随着启用datazoom。处理Touch事件以及分发showtip的基本流程为： 2.1.2.1 touchstart事件 记录触发了touchstart 记录并判断是不是多个手指，若是则隐藏tooltip，并允许datazoom。 触发长按计时器，如果是长按，则要触发tooltip，并禁用datazoom。用户移动手指，来达到连续显示tooltip。 2.1.2.2 touchmove事件 记录触发了touchmove事件 如果tooltip是不显示的状态，则要清除长按计时器，因为此时用户想要移动图表。并且，前提在tooltip是不显示的状态时，允许datazoom。如果tooltip是显示状态，则用户要达成连续显示tooltip。 如果是长按，则需要显示tooltip 2.1.2.3 touchend事件 清除长按计时器； 如果是多个手指操作，则函数结束，剩余流程不用处理； 如果是长按，则显示tooltip，重置touch事件的状态，并return； 2和3的条件都没满足的情况下，则表示用户是单次点击，如果tooltip是隐藏状态，则显示tooltip；如果tooltip是显示状态，则隐藏tooltip； 重置touch状态。 2.2 datazoom处理datazoom的处理只需要注意一个地方：拖动图表后，会触发touchend事件，可能会触发tooltip。所以，如果需要显示tooltip，则需要将在业务逻辑里面，监听到datazoom后，隐藏tooltip。","categories":[],"tags":[{"name":"chart","slug":"chart","permalink":"http://yiyan.site/tags/chart/"}]},{"title":"About:create-react-app","slug":"About-create-react-app","date":"2018-05-22T07:27:09.000Z","updated":"2018-06-07T09:08:23.635Z","comments":true,"path":"2018/05/22/About-create-react-app/","link":"","permalink":"http://yiyan.site/2018/05/22/About-create-react-app/","excerpt":"","text":"create-react-app是facebook官方维护的一套react开发框架（emmm…应该说是配置），目前的star数量接近5w+，可见其受欢迎程度。相比于其他一些react开发框架，例如react-boilerplate、react-starter-kit(star数都接近2w+)，create-react-app似乎更容易react初学者上手。 HMR(hot module replace)在使用的过程中，发现create-react-app不能做到HMR，每次修改代码都是整个页面刷新。这不可能，这么受欢迎的项目，怎么没有默认开启HMR？ 在运行npm run eject后，发现在其配置文件webpack.config.dev.js文件中已经引用相应的webpack配置： 1234567// Add module names to factory functions so they appear in browser profiler.new webpack.NamedModulesPlugin(),// Makes some environment variables available to the JS code, for example:// if (process.env.NODE_ENV === 'development') &#123; ... &#125;. See `./env.js`.new webpack.DefinePlugin(env.stringified),// This is necessary to emit hot updates (currently CSS only):new webpack.HotModuleReplacementPlugin(), 同时在webpackDevServer.config.js文件中也配置了hot： 123456// Enable hot reloading server. It will provide /sockjs-node/ endpoint// for the WebpackDevServer client so it can learn when the files were// updated. The WebpackDevServer client is included as an entry point// in the Webpack development configuration. Note that only changes// to CSS are currently hot reloaded. JS changes will refresh the browser.hot: true, 对比webpack官网，需要在入口的js文件index.js文件中增加：123if (module.hot) &#123; module.hot.accept()&#125; BrowserRouter与HashRoutervue-router有两种模式：hash模式和history模式。history模式需要服务端配合，否则会有一些小问题。 react-router中也存在这两种模式。BrowserRouter即为history模式，HashRouter即为hash模式。我们在部署的时候，如果将项目放在web服务器静态资源的二级目录中，则往往需要修改web服务器或者改用HashRouter，否则会出现找不到资源的情况。 react函数式组件，事件处理对于简单的组件，可以采用函数式来定义react组件。函数式组件可以简单快速的定义一个react组件，但是有一个缺点是：无状态。这里提供一个简单的事件处理demo：12345678910111213141516171819import React from 'react'import s from './index.less'import close from '../../assets/imgs/close.png'function Footer (props) &#123; const handleClose = () =&gt; &#123; document.querySelector('#footer').style.display = 'none' &#125; return ( &lt;footer className=&#123;s.footer&#125; id='footer'&gt; &lt;img onClick=&#123;handleClose&#125; src=&#123;close&#125; className=&#123;s.close&#125;/&gt; &lt;/footer&gt; )&#125;export default Footer","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yiyan.site/tags/react/"}]},{"title":"10-years-of-GitHub","slug":"10-years-of-GitHub","date":"2018-05-18T02:42:25.000Z","updated":"2018-07-17T09:14:09.029Z","comments":true,"path":"2018/05/18/10-years-of-GitHub/","link":"","permalink":"http://yiyan.site/2018/05/18/10-years-of-GitHub/","excerpt":"上个月，也就是2018年4月10日是GitHub十周年，GitHub创始人Chris Wanstrath发布了一篇文章来总结这十年的发展。","text":"上个月，也就是2018年4月10日是GitHub十周年，GitHub创始人Chris Wanstrath发布了一篇文章来总结这十年的发展。 回顾往昔十载，我们记住的不是某一个软件，而是人们用来做了什么。 （以下内容为译文）Chris Wanstrath： 10年前，GitHub正式上线。我们的意图其实很简单：连接开发者，让他们十分方便的通过Git一起编写项目。在过去十年里，我们已经发展成为一家公司和平台，但是GitHub的初衷不变。使这个平台特别的不是一个想法或者发明，而是使用这个平台的人们：GitHub因为你，我们的社区，才能有今天的十周年庆。 当我们回顾往昔十载，我们记住的不是某一个软件，而是人们用来做了什么。在GitHub上，我们可以与全世界一起分享、传授、创建项目。在GitHub发布时，我们没有预料到会有这么多的项目、程序和大型框架会出现在GitHub上。我们也没有想到企业会在开源社区投入如此巨大，也不曾想到会有那么多人学习彼此的代码。 GitHub发布的时候，正好是技术以新的方式将人们联系起来的时候，但是，正如我在十年前发的文章，让我们不要在旅途中高声宣扬，你的工作说明了一切。我们收集了一些我们喜欢的时刻和里程碑，以此来庆祝大家推进软件开发的方式。 展望未来，我会使GitHub保持简单。您一起定义了今天的软件，在未来几年，您将继续塑造未来。那么未来十年将会出现什么软件？我们跟随将你的领导。 与此同时，我们感谢您提交(committed)的代码、您合并的请求（pull request）、您编写的文档、您分享的项目，以及因您才有GitHub的十年。对此，我们非常感谢，迫不及待的想看看您下一步要build什么。 10年，感谢有你！2008年4月10日：GitHub正式上线在2008年4月，GitHub beta版测试完成，并正式上线，其目的仅仅是：连接开发者，让他们十分方便的通过Git一起工作。 2008年4月3日：Rails迁移到GitHub在GitHub还是beta版时，Ruby on Rails是第一个加入GitHub的开源大项目。这对GitHub而言是一个重要的时刻，因为GitHub建立在Rails之上。 2009年1月3日：比特币出现比特币是世界上第一个去中心化的数字货币，2009年被发明，并于2010年入驻GitHub。迄今为止，比特币项目已经有超过18000个分支（截止本稿，为19006个分支，star数为3w+），500多个合并请求，并激励了GitHub上数千个区块链项目，其中很多是比特币源码的分支。 2009年5月21日：Node.js发布Node.js于2009年发布，它导致人们使用JavaScript的方式发生了根本性的变化。借助Node.js，开发人员可以使用Angular、Ember、React、jQuery和Vue等库和框架，在系统上构建复杂的服务器端和桌面应用程序。该项目有效的扩展了JavaScript的可能性，并推动了一种主要的编程语言。 2014年，io.js从Node.js分化出来，致力于社区的开放性。一年后，两个项目都建立开放式的管理模式，并成立Node.js基金会进行重组，开源社区的影响力，对两个项目的重组起到了重要作用。 今天，Node.js核心拥有近2000个贡献者，Node.js也形成了丰富的生态系统，包含大量的库和工具。由于社区驱动的NodeSchool相对容易学习，NodeSchool连接开发者，提供免费教程，并在全球举办面对面的活动。 2010年11月26日：Rails Girls Summer of Code举办第一次研讨会Rails Girls(目标是为女性提供工具和社区)于2010年在Helsinki举行了首次活动。在2013年，Rails Girls成员开始筹备Summer of Code(编码夏令营):一个针对女性和非二进制编码的全球奖学金计划。学生将获得三个月的奖学金，以开展现有的开放源代码项目并扩展他们的技能。除了Google Summer of Code、Outreachy等，Rails Girls Summer of Code也对软件行业产生了影响。他们不久前举办了5周年庆典，所以现在是支持他们工作的好时机。 2011年2月28日：Travis CI的第一个pull请求Travis CI发布于2011年，其用于开源代码和私有项目的持续集成，是第一个与GitHub集成的开发者工具。Jenkins和CircleCI也在同一时间成立，这使得2011年成为CI（持续集成）和软件构建的重要一年。测试已成为编写更安全、更可靠代码的关键部分。 2012年1月1日：JavaScript成为GitHub上最受欢迎的语言2012年JavaScript的表演开始了，超越Ruby、Java和Python，成为GitHub上最流行的语言。时至今日，JavaScript仍然是GitHub上最受欢迎的语言。 2013年1月16日：GitHub社区用户达到300万在2013年晚些时候，我们的社区开源代码库达到了1000万个，其中包括Project Open Data(好像一种将数据进行开放的开源项目，以便其他人可以对数据进行管理、使用，译者不是很了解) 2014年6月9日：Docker 1.0发布在第一版发布后一年多一点，2014年6月Docker 1.0的发布，将Docker容器引入了企业数据中心和云平台。像Docker和Kubernetes这样的项目，推动了容器技术的发展，简化了DevOps，将团队从基础架构中解放出来，使得可以专注于最重要的地方。 2014年7月21日：首届Django Girls讲习班第一届Django Girls在2014年柏林EuroPython举办，开启了为期四年的世界各地软件培训和女性支持工作。 支持他们的工作，以保持Django Girls社区的成长。 2014年10月23日：微软开源.NET.NET和.NET基金会只是微软开源计划的开端。现在微软已经开源了数百个项目。它们包括去年贡献者最多的VS Code（Visual Studio Code编辑器）和2017年发展最快的语言之一：TypeScript。 微软也称为GitHub上最活跃的贡献者之一，数千名工程师、设计师和程序员在GitHub平台上贡献和发布代码。 像微软和Google这样的大公司对开源的投资，改变了人们对于商业企业构建软件的观点。他们还向我们表明，他们成功的秘诀有时不是他们所创建的技术，而是如何使用技术。 2015年3月2日：虚幻引擎4源码公布Epic Games团队免费公布了虚幻引擎4，用一些最好的工具打破了游戏开发者与他们的创意愿景之间的障碍。免费的源代码还允许社区提前体验到引擎的新特性。从bug的修复看，他们的最新版本有128位贡献者。 由于游戏引擎、相关的库和开发者工具的开源，使得游戏成为GitHub上2017年最受欢迎的主题之一。Phaser，Godot Engine和其他项目，如Itch.io，正在塑造人们建立和分享独立游戏的方式。像2048这样的开源学习资源和游戏 - 启发了数百个克隆 - 邀请了更多的人参与和创造。 受此影响，包括Doom和Price of Persia在内的一些最有影响力的游戏代码也都开源了，开源总比他们被埋没在新墨西哥沙漠（垃圾填埋场）中要好。 2015年9月22日：GitHub课堂开课GitHub课堂使教师更容易分发代码任务并收集GitHub上的作业。 今天，高中，大学和编码训练营的学生正在学习180万个课堂知识库 - 但这些远不是GitHub上唯一的教育资源。 从资源清单到像edX和Udacity这样的大型开放式在线课程（MOOC），您已经创建了数千种方法来学习GitHub上的软件开发。 我们名单上的课程包括Ada的Jumpstart计划和斯坦福大学的TensorFlow教程。 STAT545正在教授数千名学生处理数据，而CS50正在美国各地的教室中采用。 在过去的十年中，像Django Girls这样的社区驱动计划已经启动了在线教程，举办了面对面的活动，并为世界各地的学生拓宽了学习机会。 我们的校园专家还在超过15个国家的校园建立技术社区。 2015年12月3日： 苹果开源Swift将Swift作为开源语言发布的决定提高了开发新工具的标准，并鼓励更多的公司向公众发布工具。 2016年7月9日：阿波罗11号代码发射阿波罗11号于1969年登陆月球。四十七年后，启动阿波罗11号的源代码登陆GitHub。 由于其中包含的复活节彩蛋数量很大，这也证明了20世纪60年代的程序员也有幽默感。 除了存储过去的代码之外，组织正在通过开源和闭源软件推动现代航天和探索其他科学研究领域。 NASA维护着数百个开源项目。 在公共仓库中，您会发现可视化火星地形并使用TensorFlow识别系外行星的软件。 您还可以找到一些SpaceX这样的组织使用的开源项目。 2017年2月10日：Python团队执行了他们的第一个GitHub拉取请求Python的维护者宣布他们计划在2016年初迁移到GitHub上，并在第二年开始他们的第一次拉取请求。在过去十年中，Python已经成为增长最快的主要编程语言之一。自2015年以来，它在GitHub最流行语言排行榜中一直排名第三。 Python的历史可以追溯到20世纪90年代初，但近年来它变得越来越重要。 这可能是由于其社区建立了庞大的数据科学和机器学习工具生态系统。 2017年2月15日：TensorFlow 1.0发布谷歌首先在2015年将其内部机器学习库TensorFlow公开。去年，它是GitHub上分支最多的项目之一，TensorFlow / models库在2017年的访问量比2016年多5.5倍。现在，TensorFlow是一个 为数据专业人员创建机器学习模型的首选工具。 近年来，机器学习的可能性已经超出限制。 组织和个人使用TensorFlow创建诊断精神疾病，分类皮肤癌，组合音乐和开动Mario Karts（自动驾驶）的模型。 今天，数据科学家可以使用一系列开源深度学习工具和模型来解决复杂而有趣的问题。 除了TensorFlow之外，Caffe2，Sonnet，DeepSpeech和Keras等工具以及pandas和Jupyter等数据分析工具也支持跨行业的数据科学工作。 2017年5月2日：30,000个非营利帐户被创建非营利组织和非政府组织（NGO）通过技术发生令人难以置信的事情。 去年，我们通过Human Utility，Maven和ConnectHome等举措让30,000个非营利用户使世界变得更美好。 野生动物保护协会（WCS）的海洋保护努力涵盖25个国家，以保护和保护世界珊瑚礁。 在肯尼亚，WCS使用软件收集全球研究人员的数据，并通过收集物种数据和监测更多252公顷的沿海礁石 - 约260个足球场的价值，帮助当地社区更有利可图地进行捕捞。 2017年5月31日：第1亿次拉取请求很多bug被修复，众多新功能发布以及软件的不断改进。事实上，仅2017年，社区便贡献了2.9万亿行代码。 2018年4月10日：代码、协作和提交的十年GitHub正式推出十年后，我们的社区已经发展到全球拥有超过8000万个项目的2700万名开发人员。 感谢您创建的代码库，您所做的贡献以及您一起构建的软件。 感谢当了10年码农的你（哈哈，差不多这个意思啦）。","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yiyan.site/tags/GitHub/"}]},{"title":"top-frameworks-trends-2018","slug":"top-frameworks-trends-2018","date":"2018-05-17T10:54:45.000Z","updated":"2018-05-17T11:31:14.639Z","comments":true,"path":"2018/05/17/top-frameworks-trends-2018/","link":"","permalink":"http://yiyan.site/2018/05/17/top-frameworks-trends-2018/","excerpt":"","text":"来自85个国家的超过1,000名参与者和大量数据，JAXenter调查了2018年哪些技术主题值得关注，并与历史进行了对比。 Web框架React、Angular和Node.js排名占据前3，我们可以看出JavaScript开发框架可以说是最近几年最受欢迎的web框架。排在第四位的是Java生态系统的Spring MVC，紧接其后的是国内大受欢迎的Vue.js。 我们来回顾一下2016年和2017年，web框架的排名。 Angular在2016年的时候可能不叫受欢迎，但是后来被React后来居上。React在今年将会继续超越Angular。Java生态的web框架越来越不受欢迎了，例如Spring MVC.## 应用程序框架Java生态中Spring Boot越来越受欢迎。不知道新秀Eclipse MicroProfile未来表现如何。 对比2016年和2017年的发展趋势： UI toolkits2018年，HTML5将是绝对的王者，紧随其后的是Bootstrap和Web组件。 来看一下Java UI toolkits在2016年和2017年的情况。 程序员们对JavaFX的兴趣似乎有所减少，但是它仍然排在Swing和SWT前。需要注意的是，从JDK11开始，JavaFX将作为与JDK分离，作为独立的模块。Oracle在一份白皮书中写道，截至2022年3月，JavaFX新修补程序将继续得到Java SE 8的支持，并宣布他们“正在与感兴趣的第三方合作，以便更容易地构建和维护JavaFX作为单独分发的开源模块“。我们来对比一下UI Frameworks在2016年和2017年的表现： JavaScriptJavaScript框架显然是这次的精华，让我们仔细看看过去三年情况如何变化。 React、Angular和Node.js遥遥领先，HTML5和Bootstrap的阵地也很大。Web Components是一套不同的技术（不是React中所涉及到的组件），允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的web应用中使用它们，有点类似React，但是区别也挺大，很容易被人忽视，因为React、Vue中也有组件的概念，不知道其发展将如何。","categories":[],"tags":[]},{"title":"Go语言的5大开源库","slug":"top5-libraries-for-Go","date":"2018-05-13T04:07:07.000Z","updated":"2018-05-17T09:26:30.098Z","comments":true,"path":"2018/05/13/top5-libraries-for-Go/","link":"","permalink":"http://yiyan.site/2018/05/13/top5-libraries-for-Go/","excerpt":"","text":"Go语言可以说是一个开箱即用的编程语言，其性能出众、支持分布式等特性深得程序员的喜爱。小编之前在毫无Go语言开发经验的情况下，只花了一个星期便掌握了Go语言的基本特性，后来也没花几天便搭建了一个数据库为mongoDB的服务器，并实现了相当复（chong）杂（fu）的功能，可见其上手非常简单。 下面介绍5个在GitHub上比较火热的Go语言开源工具库。 Go kit：微服务工具包Go kit微服务工具包为微服务提供了一系列的功能，使搭建微服务特别方便，开发人员只需要关注业务逻辑即可。限于篇幅，这里列出Go kit提供的几项功能： jwt(JSON web token):一种认证通信双方的协议 RPC（远程过程调用）基础支持 grpc：Google开源RPC框架 http服务 LB负载均衡 ZK（ZooKeeper）支持：分布式服务框架 Graphite:支持监控系统 InfluxDB: 时间序列数据库 GORMORM是什么？对象关系映射（Object Relational Mapping）,是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。通俗一点讲：操作数据库。GORM具有很多功能，具其官网介绍，具备一下功能： 全功能ORM（无限接近） 关联（包含一个，包含多个，属于，多对多，多态） 钩子 (在创建/保存/更新/删除/查找之前或之后) 预加载 事务 复合主键 SQL 生成器 数据库自动迁移 自定义日志 可扩展性, 可基于 GORM 回调编写插件 所有功能都被测试覆盖 开发者友好 clicli，可以用来快速的创建go语言命令行工具，目前在GitHub上的star数为8k+。 vegetavegetahttp负载测试工具。 fuzzyfuzzy,go语言实现的字符串模糊匹配工具。 build-web-application-with-golang除了上面提到的几个工具外，在GitHub上还有一个比较火热的项目，star数量达到了2万多。其实，称之为项目并不准确，应该说是博客，它从零开始，详细的介绍了如何一步步搭建Go语言开发环境、搭建web服务器、连接数据、部署等等，几乎一整套的Go语言建站方法，它就是:build-web-application-with-golang。它不仅有中文版，还有英文、法文、日文版等等多种语言。从介绍页面上，其包含浓浓热情、求赞助的支付二维码来看，这是国内开发者贡献的，点赞！","categories":[],"tags":[]},{"title":"Parcel打包初体验","slug":"how-about-Parcel","date":"2018-05-11T03:16:10.000Z","updated":"2018-05-14T07:02:09.535Z","comments":true,"path":"2018/05/11/how-about-Parcel/","link":"","permalink":"http://yiyan.site/2018/05/11/how-about-Parcel/","excerpt":"","text":"Parcel号称极速零配置Web应用打包工具，相比于webpack的复杂性，Parcel确实为我们省去了很多配置。使用过facebook/create-react-app的同学应该会发现，creat-react-app也简化了配置，其包含react-scripts包，这个包做的事正与Parcel类似：将所有的打包配置统筹、封装。 Parcel基本用法安装Parcel全局安装Parcel:Yarn:1yarn global add parcel-bundler npm:1npm install -g parcel-bundler 创建、运行项目创建文件夹，并在文件夹下新建入口html和js文件，html引入入口js文件。12345&lt;html&gt;&lt;body&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1console.log(\"hello world\") 在文件夹下初始化项目：1yarn init -y 或1npm init -y 启动服务开始开发：1parcel index.html Parcel的基本用法介绍就此为止，就是这么简单，官网上有更详细的介绍。 项目迁移我们现在尝试将webpack配置的项目迁移到Parcel。 vue-cli webpack我们首先使用vue-cli创建一个项目:1vue init webpack parcel-test 首先进入项目运行一下npm run dev，检查是否能运行成功，OK！运行成功。然后我们直接运行parcel index.htmlDANG!DANG! emmmmm… 好像没有将main.js引入html文件。改！ 修改引用路径。重启服务，出现错误 由于我们在App.vue中使用了template函数，而import Vue from &#39;vue&#39;默认引用的运行时态版（不支持template函数），所以需要改用vue完整版。vue修改main.js和router/index.js文件中vue的引用1import Vue from 'vue/dist/vue.esm.js' 再来运行一次parcel index.html便成功了，可以正常开发了。 小缺陷Parcel目前支持CommonJS 和 ES6 两种模块语法，所以，如果你在index.html页面引入了项目中非上述两种模块语法开发的js，那么可能会出现意外情况。如果还是想引入非CommonJS和ES6模块语法开发的js，目前可以有两种解决方法: 如果有源码，则改造代码 没有源码，并且还是压缩的，将其放在服务器上，html通过域名引用 将第三方的代码内联到html中 总结总体而言，Parcel确实比webpack要简化很多，几乎是开箱即用。对于没有特殊要求的项目，推荐使用。","categories":[],"tags":[{"name":"Parcel JavaScript","slug":"Parcel-JavaScript","permalink":"http://yiyan.site/tags/Parcel-JavaScript/"}]},{"title":"ES2017中async&await踩坑指南","slug":"async-and-await-comprehensive-guide","date":"2018-05-10T08:15:26.000Z","updated":"2018-05-10T11:03:28.853Z","comments":true,"path":"2018/05/10/async-and-await-comprehensive-guide/","link":"","permalink":"http://yiyan.site/2018/05/10/async-and-await-comprehensive-guide/","excerpt":"","text":"ES2017标准引入了async、await函数，使得异步操作变得更加方便了，而不用每次new Promise(...)了 本文还使用到了es6的其他特性，例如箭头函数=&gt;，以及不用说的Promise，所以为了在生产上兼容，需要引入babel-polyfill，并对代码进行Babel处理。这里暂时不对相关知识进行细说。如果你使用最新版的Chrome浏览器进行开发调试，就可以暂时不用关心相关知识了。 基本用法asyncasync其实是Promise语法糖。我们首先来写一个Promise：1234567891011121314151617function asyncWork () &#123; return new Promise((resolve, reject) =&gt; &#123; // TODO something var isSucc = true if (isSucc) &#123; reslove() &#125; else &#123; reject() &#125; &#125;)&#125;function doWrok () &#123; asyncWork().then(resp =&gt; &#123; console.log('success') &#125;)&#125; 将其改为async写法：123456789101112131415async function asyncWork () &#123; // TODO something var isSucc = true if (isSucc) &#123; return &#125; else &#123; throw 'error' &#125;&#125;function doWork () &#123; asyncWork().then(resp =&gt; &#123; console.log('success') &#125;)&#125; 可以看到使用async语法糖后，asyncWork代码量减少了，特别是在代码逻辑比较复杂的时候，使用async会直观很多。 await往往使用await的函数需要使用async。 async表示异步，而await表示需要等待。进一步说，async函数可以看成将异步操作包装成一个Promise对象，而await就是then命令的语法糖。await使用方法：12345678910111213141516171819202122async function asyncWork () &#123; // TODO something var isSucc = true if (isSucc) &#123; return &#125; else &#123; throw 'error' &#125;&#125;async function doWork () &#123; // 将等待两个asyncWork的返回结果，然后执行下一步 var workResult1 = await asyncWork() var workResult2 = await asyncWork() return workResult1 + workResult2&#125;function mainWork() &#123; doWrok.then(resp =&gt; &#123; console.log(resp) &#125;)&#125; 当然，也可以将上面的asyncWork方法改为使用Promise。 进阶踩坑既然使用了javaScript的ES2017特性，那么你一定会使用箭头函数=&gt;。相应的，在实际项目中，为了兼容性，我们会使用babel-preset-env等进行转义。坑来了，我们将上面的doWork方法改为如下：12345678910async function doWork () &#123; var array = [1, 2, 3] array.forEach(item =&gt; &#123; // 将等待两个asyncWork的返回结果，然后执行下一步 var workResult1 = await asyncWork() var workResult2 = await asyncWork() console.log(workResult1 + workResult2) &#125;) console.log(array)&#125; 我们来创建两个文件index.html、main.js来进行验证: index.html:12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;async&amp;await&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;script src=\"./main.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; main.js1234567891011121314151617181920212223242526async function asyncWork () &#123; // TODO something var isSucc = true if (isSucc) &#123; return &#125; else &#123; throw 'error' &#125;&#125;async function doWork () &#123; var array = [1, 2, 3] array.forEach(item =&gt; &#123; // 将等待两个asyncWork的返回结果，然后执行下一步 var workResult1 = await asyncWork() var workResult2 = await asyncWork() console.log(workResult1 + workResult2) &#125;) console.log(array)&#125;function mainWork() &#123; doWrok.then(resp =&gt; &#123; console.log(resp) &#125;)&#125; 这里，我们使用Pracel来进行打包。Parcel号称极速零配置Web应用打包工具，但是还是需要一点点配置的（当然也有一些限制），不过比那个vue-cli的webpack模板配置要简单多了!!! 使用npm init或者yarn init对项目初始化后，命令行运行：parcel index.html，运行结果： OMG!!!竟然报错了，什么情况？async、await这对鸳鸯成对出现了，怎么还会报错？！且慢，我们不妨看看Parcel对doWork的处理结果是什么。我们打开项目下的dist文件夹。dist文件夹下存放了Parcel的打包结果。 …哈哈，竟然只有index.html文件。那我们上述doWork函数改一下：12345678910async function doWork () &#123; var array = [1, 2, 3] for (var i = 0; i &lt; array.length; i++) &#123; // 将等待两个asyncWork的返回结果，然后执行下一步 var workResult1 = await asyncWork() var workResult2 = await asyncWork() console.log(workResult1 + workResult2) &#125; console.log(array)&#125; 再次运行parcel index.html，编译成功： 机智的我们发现是箭头=&gt;函数在添乱。我们再看一下es6中=&gt;的定义：123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 那上面包含箭头函数的doWork也就等同于：12345678910async function doWork () &#123; var array = [1, 2, 3] array.forEach(function(item) &#123; // 将等待两个asyncWork的返回结果，然后执行下一步 var workResult1 = await asyncWork() var workResult2 = await asyncWork() console.log(workResult1 + workResult2) &#125;) console.log(array)&#125; 外层的doWork函数和包裹await的函数已经不是同一个函数了，所以Parcel编译失败。如果想继续使用箭头函数，可以改为：12345678910function doWork () &#123; var array = [1, 2, 3] array.forEach(async(item) =&gt; &#123; // 将等待两个asyncWork的返回结果，然后执行下一步 var workResult1 = await asyncWork() var workResult2 = await asyncWork() console.log(workResult1 + workResult2) &#125;) console.log(array)&#125; 所以，async、await、=&gt;等es6特性，在使用时要注意它们的作用，避免增加不必要的调试时间。","categories":[],"tags":[]},{"title":"前端代码如何调试？","slug":"how-to-debug-web-code","date":"2018-05-06T08:57:44.000Z","updated":"2018-05-25T10:58:58.432Z","comments":true,"path":"2018/05/06/how-to-debug-web-code/","link":"","permalink":"http://yiyan.site/2018/05/06/how-to-debug-web-code/","excerpt":"","text":"前端代码的调试即javaScript调试，调试方法有很多，不同的开发者有不同的调试方式。这里介绍几种从入门到入坑的调试方法。 最简单调试方法：打印日志打印日志不仅仅是前端代码的调试方法，它几乎是大部分开发语言的入门级调试方法。很多开发者在新手阶段都会采用这一方式，将变量值等信息打印出来。javaScript输出日志主要方法是console对象。console对象有很多个方法，例如console.assert、console.clear、console.count等方法，其中与日志输出有关的方法有： 1234567console.log() // 打印字符串console.info() //打印一条信息console.error() // 打印一条错误信息console.warn() //打印一个警告信息 打印日志的调试方法超级简单，只需要在需要查看信息的代码行调用上面的方法即可输出想要的信息。上述4个方法均可将对象打印出来，例如：12345var person = &#123; name: 'Rose'&#125;console.info('person', person) 如果使用的是Chrome浏览器，右键页面=&gt;检查，在console中即可看到相应的输出: 代码中插入debuggerjavascript提供了一个关键字：debugger，这个语句厉害了，可以调用任何可用的调试功能，设置断点。但是，如果没有调试功能可用，此语句将不起作用。下面是一个包debugger语句的html代码，当代码被执行时，会尝试调用一个可用的调试器进行调试。1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;test&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var a = 1 a = a + 1 debugger a = a + 2&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 保存该文件，使用Chrome浏览器将其打开。打开Chrome developer tool， 即右键页面=&gt;检查，发现没啥呀，只有下面这个页面： 此时我们刷新页面，dang～dang～，变这样了： 看到图中标红的地方了吗？那就是我们设置的断点，程序运行到那里停止了。此时我们将鼠标移至变量a上，即可看到a的值。下图中红圈内数字也可以设置断点。 编辑器中调试c++、Java、c#等语言都能在编辑器中进行调试、打断点，主要原因是它们都可以在编辑器中运行，而Web前端代码只能运行在浏览器中。 webstormwebstorm可以在编辑器中进行调试、打断点，十分方便。但是，webstorm运行时占用资源比较多，对于性能比较低的电脑，webstorm运行的不是很流畅。webstorm的调试方法可以在官网中找到。 Sublime TextSublime Text是一个比较轻量的脚本编辑器，运行比较流畅，很多前端开发者都喜欢使用。Sublime Text有几个可以实现调试的Package，但是试用了一下，没有成功 Visual Studio CodeVisual Studio Code具有Sublime Text轻量，同时也能实现调试，简直要抛弃Sublime Text投靠Visual Studio Code的怀抱了❤️ 1、安装Debugger for Chrome插件安装最新版的Visual Studio Code后，打开它，点击左侧扩展图标 在“在商店中搜索扩展”中输入“Debugger for Chrome”，安装Debugger for Chrome即可 安装成功后，先新建文件夹test/src，在其中新建index.html和index.js两个文件1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;o&lt;/div&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt; &lt;script&gt; var result = add(1, 2) console.info('html', result) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js: 123456function add(a, b) &#123; return a + b&#125;var result = add(1, 2)console.info(result) 首先在index.js中打一个断点。点击图中红框区域即可添加断点，也可将鼠标放在红框区域右键添加、删除断点 选中test文件夹，按快捷键F5，或者点击调试-&gt;启动调试，选择Chrome。Visual Studio Code会自动在test文件夹下创建.vscode/launch.json文件。修改launch.json文件，修改或增加途中红线标识的行。 然后再次按F5或启动调试，此时Chrome会自动打开index.html，刷新页面，即可发现Visual Studio Code在刚才我们添加的断点出阻塞了 移动端网页调试移动端主要分Android和iOS，Windows Phone就暂时不考虑了，2017年销售的智能手机，99.9%的搭载了这两个操作系统。 Android端调试Android手机调试首先需要开启开发者模式，其次，如果是调试浏览器则需要安装Chrome浏览器，若是调试其他APP则需要APP开发者打开调试的开关。 完成上述步骤后，打开网页，使用usb线链接电脑，允许电脑调试手机。在PC端Chrome浏览器地址栏输入chrome://inspect iOS端调试网页macOS操作系统调试iOS网页比较简单，只需iPhone设置-&gt;Safari-&gt;高级-&gt;打开Web检查器开关，打开网页，iPhone通过数据线连接Mac电脑，打开Mac端Safari，点击开发-&gt;[你的手机]-&gt;选择调试的网页 也可以使用iPhone模拟器调试，前提需要安装Xcode。上图正是模拟器调试。 Windows操作系统要调试iOS端网页，则需要通过Chrome调试，并安装一些工具便可以调试Safari了 最强大的调试方法使用浏览器自带的调试工具，可以说是最常用，也是最强大的调试方法。不仅可以调试自己开发的网页，也可以hack其他网页，从别人那里学习一些前端知识。 Chrome浏览器的调试功能比较强大,其拥有很多功能，不仅可以查看、整理代码，还可以检查网页的性能、动画等等 Firefox浏览器调试功能也同样强大，完全媲美Chrome。最新版的Firefox在性能上有了很大的提升，渲染网页的速度赶超Chrome，资源占用却没有Chrome高。 国产浏览器中，如搜狗浏览器、UC浏览器等都支持调试，部分内核使用了Chromium，也就是Chrome内核，调试功能和Chrome差不多，可能有版本延迟，缺少部分新功能。","categories":[],"tags":[{"name":"h5  web debug","slug":"h5-web-debug","permalink":"http://yiyan.site/tags/h5-web-debug/"}]},{"title":"WEEX开发实现native端hotreload","slug":"weex-hotreload","date":"2018-02-27T06:13:31.000Z","updated":"2018-02-27T06:36:52.433Z","comments":true,"path":"2018/02/27/weex-hotreload/","link":"","permalink":"http://yiyan.site/2018/02/27/weex-hotreload/","excerpt":"","text":"相关版本：weex-toolkit: 1.2.9playground: 0.5.2.5 在进行weex开发，修改代码时，网页能进行自动刷新，方便开发人员看到改动。但是，在app端，由于加载的仅仅是业务代码的js文件，不能实现自动刷新。 在官方提供的playground app中，在界面上添加了刷新按钮，来手动刷新。but…有点懒，想想其他办法。 在playground的代码中发现了hotreoload的相关代码：WXPageActivity.java1234567891011121314151617181920212223242526272829 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_wxpage); setCurrentWxPageActivity(this); ... if(WXPAGE.equals(mUri.getScheme())|| ... startHotRefresh(); ... &#125;else if (TextUtils.equals(\"http\", mUri.getScheme()) || TextUtils.equals(\"https\", mUri.getScheme())) &#123; ... startHotRefresh(); &#125; ... &#125;/** * hot refresh */ private void startHotRefresh() &#123; try &#123; String host = new URL(mUri.toString()).getHost(); String wsUrl = \"ws://\" + host + \":8082\"; mWXHandler.obtainMessage(Constants.HOT_REFRESH_CONNECT, 0, 0, wsUrl).sendToTarget(); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; &#125; 虽然有hot refresh的代码，但是没用。因为startHotRefresh()中监听的是String wsUrl = &quot;ws://&quot; + host + &quot;:8082&quot;; 8082端口，而我们的weex-toolkit创建的项目没有创建相应的socket server。 估计官方填坑只填了一半。怎么肥四！？ 通过浏览器的开发者模式，我们可以看到webpack-dev-server创建了websocket server. 有戏了！我们可以在app端创建webscoket与webpack-dev-server连接。下面我们对webpack-dev-server源码进行分析 打开node_modules文件夹下的webpack-dev-server.我们主要看client/index.js和lib/Server.js文件： client/index.js获取webscoket地址和端口，赋值为urlParts：1234567891011121314151617181920var urlParts = void 0;var hotReload = true;if (typeof window !== 'undefined') &#123; var qs = window.location.search.toLowerCase(); hotReload = qs.indexOf('hotreload=false') === -1;&#125;if (typeof __resourceQuery === 'string' &amp;&amp; __resourceQuery) &#123; // If this bundle is inlined, use the resource query to get the correct url. urlParts = url.parse(__resourceQuery.substr(1));&#125; else &#123; // Else, get the url from the &lt;script&gt; this file was called with. var scriptHost = getCurrentScriptSource(); // eslint-disable-next-line no-useless-escape scriptHost = scriptHost.replace(/\\/[^\\/]+$/, ''); urlParts = url.parse(scriptHost || '/', false, true);&#125;if (!urlParts.port || urlParts.port === '0') &#123; urlParts.port = self.location.port;&#125; 初始化对scoket消息的处理：123456789101112131415161718var onSocketMsg = &#123; hot: function hot() &#123; _hot = true; log.info('[WDS] Hot Module Replacement enabled.'); &#125;, invalid: function invalid() &#123; log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain. if (useWarningOverlay || useErrorOverlay) overlay.clear(); sendMsg('Invalid'); &#125;, ... 'content-changed': function contentChanged() &#123; log.info('[WDS] Content base changed. Reloading...'); self.location.reload(); &#125;, ...&#125;; 链接websocket服务器：123456789var socketUrl = url.format(&#123; protocol: protocol, auth: urlParts.auth, hostname: hostname, port: urlParts.port, pathname: urlParts.path == null || urlParts.path === '/' ? '/sockjs-node' : urlParts.path&#125;);socket(socketUrl, onSocketMsg); 上文中，我们可以看到，webscoket客户端接收到content-changed消息后self.location.reload();对页面进行刷新。 我们再看看websocket服务器端是否发送了content-changed消息。 lib/Server.js发送content-changed消息：123456789101112131415161718192021222324Server.prototype._watch = function (watchPath) &#123; // duplicate the same massaging of options that watchpack performs // https://github.com/webpack/watchpack/blob/master/lib/DirectoryWatcher.js#L49 // this isn't an elegant solution, but we'll improve it in the future const usePolling = this.watchOptions.poll ? true : undefined; // eslint-disable-line no-undefined const interval = typeof this.watchOptions.poll === 'number' ? this.watchOptions.poll : undefined; // eslint-disable-line no-undefined const options = &#123; ignoreInitial: true, persistent: true, followSymlinks: false, depth: 0, atomic: false, alwaysStat: true, ignorePermissionErrors: true, ignored: this.watchOptions.ignored, usePolling, interval &#125;; const watcher = chokidar.watch(watchPath, options).on('change', () =&gt; &#123; this.sockWrite(this.sockets, 'content-changed'); &#125;); this.contentBaseWatchers.push(watcher);&#125;; 现在弄清楚了webpack-dev-server的hotreload。诶…我们似乎跑远了。 app客户端需要监听websocket server，当收到content-changed消息时，对页面进行刷新。 Android客户端链接webpack-dev-server的socket服务器直接链接host:8081端口无法成功。在分析lib/Server.js代码，发现了这样一句代码：12345...sockServer.installHandlers(this.listeningApp, &#123; prefix: '/sockjs-node'&#125;);... 再看webpacke-dev-server使用的socket库sockjs-node，发现了这样一段话： 于是，将Android客户端的socket链接地址改为ws://host:8081/sockjs-node/websocket。成功了！！！socket链接打通。Android端部分代码：123456789101112private void startHotRefresh() &#123; try&#123; URL host = new URL(mUri.toString()); String wsUrl = \"ws://\" + host.getHost() + \":\" + host.getPort() + \"/sockjs-node/websocket\"; if (host.getPort() &lt; 0) &#123; wsUrl = \"ws://\" + host.getHost() + \"/sockjs-node/websocket\"; &#125; ... &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; &#125; 走到这里，只剩下对消息的处理。修改js代码，在playground的HotRefreshManager.java中打印接收到的消息，发现没有content-changed,接收到的都是{&quot;type&quot;:&quot;progress-update&quot;,&quot;data&quot;:{&quot;percent&quot;:95,&quot;msg&quot;:&quot;emitting&quot;}}。万幸的是消息最后跟了一个{&quot;type&quot;:&quot;ok&quot;}。所以，暂且将{&quot;type&quot;:&quot;ok&quot;}作为触发刷新的点。 在HotRefreshManager.WXWebSocketListener:12345678@Overridepublic void onMessage(WebSocket webSocket, String text) &#123; Log.i(\"Receiving : \", text); if (text.equals(\"&#123;\\\"type\\\":\\\"ok\\\"&#125;\")) &#123; Log.i(\"onMessage\", \"done\"); mHandler.obtainMessage(Constants.HOT_REFRESH_REFRESH).sendToTarget(); &#125;&#125; 最后，成功实现Android端自动刷新页面的效果。 文中还有不完善的地方，待后续补充。","categories":[],"tags":[]},{"title":"JavaScript的内存管理，以及如何处理4种常见的内存泄漏","slug":"js-memory-manager-md","date":"2018-02-27T03:12:22.000Z","updated":"2018-02-27T05:51:06.670Z","comments":true,"path":"2018/02/27/js-memory-manager-md/","link":"","permalink":"http://yiyan.site/2018/02/27/js-memory-manager-md/","excerpt":"","text":"JavaScript的内存管理，以及如何处理4种常见的内存泄漏起初从一个公众号中看到了这篇文章，拜读的时候发现有一两处地方有点难懂。于是尝试翻译一下原文，原文地址为How JavaScript works: memory management + how to handle 4 common memory leaks 作者针对JavaScript写了一系列的文章，第三篇便是此文章。第一篇和第二篇分别是How JavaScript works: an overview of the engine, the runtime, and the call stack、How JavaScript works: inside the V8 engine + 5 tips on how to write optimized code 文章开头讲叙了一些内存方面的基础知识，这里略过直接开车。 JavaScript的内存分配JavaScript对内存的分配进行自动管理，而不同于C语言需要开发者管理。123456789101112131415var n = 374; // 为数字分配内存var s = 'sessionstack'; // 为字符分配内存var o = &#123; a: 1, b: null&#125;; // 为object和其属性分配内存var a = [1, null, 'str']; // 分配数组空间function f(a) &#123; return a + 3;&#125; // 为方法分配内存（方法本质上是一个可以回调的object）// 函数表达式也作为object来分配内存someElement.addEventListener('click', function() &#123; someElement.style.backgroundColor = 'blue';&#125;, false); 一些函数的返回结果也当作object分配内存：123var d = new Date(); //分配一个Date objectvar e = document.createElement('div'); // 分配一个DOM 元素 一些方法也能分配新的值或object内存空间：12345678var s1 = 'sessionstack';var s2 = s1.substr(0, 3); // s2 是一个新的字符变量// 由于已分配内存空间的字符,在内存空间中值是不变的// JavaScript可能不会给2分配新的内存空间,而是仅仅记录[0, 3]的区间.var a1 = ['str1', 'str2'];var a2 = ['str3', 'str4'];var a3 = a1.concat(a2);// 数组拼接将会分配新的内存空间 当内存不再需要时，内存空间会被释放大多数的内存管理问题都出现在这个阶段。在这个阶段，比较难的是如何判断内存空间可以释放掉了。这通常需要开发者确定哪些内存不再需要，然后将其释放。高等级的编程语言都会集成垃圾回收器。垃圾回收器对内存的分配和使用进行跟踪。当分配的内存不再需要时，垃圾回收器将会释放内存。 然而，总是有一些内存片段，垃圾回收器的算法难以判断其是否需要。大多数的垃圾回收器通过收集不再访问的内存，例如所有指向该内存的变量都已经不存在了。但是，可能存在一个变量一直指向某一内存空间，而程序不再使用该变量。 垃圾回收由于难以决定内存是否继续需要，垃圾回收器难以提供相应的解决方案。本节我们将会对垃圾回收器的回收算法一探究竟，并发现其存在的缺陷。 内存引用垃圾回收算法主要依赖于引用。 在内存管理这中，引用是一个对象可以访问(显式或隐式)另一个对象。例如，JavaScript对象继承了Object.prototype的属性和方法。其继承Object。prototype便是隐式引用，属性和方法便是显式继承。 垃圾回收算法：引用计数（reference-counting）rc垃圾回收是最简单的垃圾回收算法。如果指向对象的引用数量为0则这个对象是可以回收的。 看一下以下代码：12345678910111213141516var o1 = &#123; o2: &#123; x: 1 &#125;&#125;// 创建了2个对象。其中，‘o2’被'o1'对象引用，作为'o1'的属性// 'o1'和'o2'都不能被回收var o3 = o1; //o3引用o1o1 = 1; // o1重新赋值，o1原来的内存现只被o3引用var o4 = o3.o2 // o4引用o2属性。现在o2属性在两处被引用o3 = '374' // 原o1的内存空间，被引用次数为0。但是其属性o2仍然被o4引用，不能被回收o4 = null // o2不再被o4引用，原o1引用数为0，现在可以被回收了 内存泄漏：循环引用下面的例子中，两个对象相互引用。方法调用完后，两个对象将不再需要，可以被释放。然而，rc垃圾回收算法认为每个对象都被引用了，所以不会回收。123456function f() &#123; var o1 = &#123;&#125; var o2 = &#123;&#125; o1.p = o2 // o1引用o2 o2.p = o1 // o2引用o1, 这就产生了循环引用&#125; 垃圾回收算法：标记&amp;扫描（mark&amp;sweep）为了判断一个对象是否可以释放，m&amp;s算法是通过判断对象是否可达。 m&amp;s算法流程如下： 垃圾回收器首先建立了一个roots列表。roots通常是一些存在引用的全局变量，可以理解为引用的入口。在JavaScript中，“window”对象就是一个可以作为入口的全局对象 所有的root都被检查，并被标记为活动状态，也就是非垃圾。同时，所有root的所有孩子节点都也被递归检查。所有能从root可达的对象都不是垃圾。 剩余没有油被标记为活动状态的对象，都可以作为垃圾回收。垃圾回收器可以释放相应的内存，归还给系统。 m&amp;s算法要优于前面提到的引用计数算法，因为引用计数算法会导致一些对象从root不可达，而其又被引用了。m&amp;s算法可以释放部分存在循环引用的内存空间。 截止2012年，所有的浏览器都采取了m&amp;s垃圾回收机制。这里 详细介绍了垃圾机制，其中也包括m&amp;s垃圾回收机制及其优化。 循环引用不再是问题在上面的第一例子中，方法调用完后，方法中的两个对象不能从root可达，将被垃圾回收标记为不可达，进而被垃圾回收器回收。 垃圾回收机制的缺陷虽然垃圾回收器能够自动回收不再使用的内存空，但是，垃圾回收器执行回收的时机是不可预测的，也就是我们不知道垃圾回收什么时候会执行m&amp;s流程。有些情况下，即使里创建了一个数组，只要浏览器的可用内存足够，垃圾回收器可能就不会执行回收操作。 什么是内存泄漏内存泄漏可以定义为：应用程序不再需要的内存空间，由于某种原因，内存空间没有被系统回收，没有回到系统的可用内存池中。 编程语言通常有多种方法管理内存。但是，编程语言很难判断某一内存空间是否被使用。换句话说，只有开发者能明确的告诉浏览器某一内存空间是否能被系统回收。编程语言为开发提供了一些执行相应操作的功能，其他则需要开发者自身明确什么时候使用了内存。Wikipedia上有一些关于自动和人工管理内存的文章。 四种常见的内存泄漏1. 全局变量JavaScript处理没有申明的变量方式是将其作为浏览器的window的属性：123function foo(arg) &#123; bar = 'some text'&#125; 等同于:123function foo(arg) &#123; window.bar = 'some text'&#125; 浏览器测试效果： 所以，如果不小心忘记使用var或let等等申明bar变量，将会在方法内创建全局变量。使用ESlint进行代码规范是个不错的选择。 另一不小心创建全局变量的途径是通过this ： 12345function foo() &#123; this.var1 = 'potential accidental global'&#125;// 调用foo方法时，‘this’指向全局对象window，而不是undefinedfoo() 为避免这样的错误发生，建议在js文件第一行加入use strict。这能阻止意外产生全局变量。有关strict模式的更多内容，可以查看这里 严格模式。 在申明全局变量时建议赋值为null，在程序需要的地方再分配内存。 2. 遗漏计时器或者回调函数JavaScript的setInterval和setTimeout方法，如果不主动回收都可能导致内存泄漏。 关于回调函数导致的内存泄漏，原文提到了addEventListener和removeEventListener函数。然而，现代的浏览器都会在DOM被销毁时，其上绑定的事件也都会被回收，并不是严格要求addEventListener后，必须removeEventListener后才能回收内存。 3. 闭包JavaScript开发的一个重要特性就是闭包：内部的方法能够访问到外部（闭环）方法的变量。由于JavaScript运行时的具体实现，下面的代码可能导致内存泄漏： 123456789101112131415161718var theThing = nullvar replaceThing = function () &#123; var originalThing = theThing var unused = function () &#123; if (originalThing) // 引用originalThing console.log('hi') &#125; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log('message') &#125; &#125;&#125;setInterval(replaceThine, 1000) 该代码执行内容是：每次replaceThing方法被调用，theThing都获取到一个包含大数组属性和闭包（函数）。同时，变量unused获得一个引用originalThing的闭包。是不是有点懵了？其实，只要记住一点：对子闭包而言，同一父闭包的内存空间是共享的。 在上面的例子中，unused是可以访问到someMethod的。在方法replaceThing方法外面，theThing可以调用someMethod。由于someMethod与unused共享闭包区域，unused对originalThing的引用，导致someMethod一直保持活动状态，阻止了其被回收，即使unused方法没有被回调。 仔细一想，原文的意思应该如下图所示： 随着定时器的执行，不断的有新的内存空间被分配，同时老的内存空间依然被引用，得不到释放。这个问题是Meteor团队发现的 4. DOM外引用有时候我们可能需要存储一些DOM的引用，以便多次访问。但是，当引用的DOM元素被从页面移除时，我们存储的DOM引用可能会导致内存泄漏。例如：12345678910111213var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image')&#125;function doStuff() &#123; elements.image.src = 'http://example.com/image_name.png'&#125;function removeImage() &#123; document.body.removeChild(document.getElementById('image')) // 这时，我们依然在全局变量elements中引用了image，也就是，image元素仍然保存在内存中，不会被垃圾回收器回收&#125; 所以，我们在创建引用的时候需要注意对DOM的引用。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yiyan.site/tags/JavaScript/"}]}]}